
[如何在 Vue.js 中使用第三方库 · Issue #51 · dwqs/blog](https://github.com/dwqs/blog/issues/51)
[Use Any Javascript Library With Vue.js](https://vuejsdevelopers.com/2017/04/22/vue-js-libraries-plugins/?jsdojo_id=reddit_lip)
[Vue 学习总结 - Xheldon](http://www.xheldon.com/vue-learning-summary.html)
[mvvm学习&vue实践小结 | AlloyTeam](http://www.alloyteam.com/2015/06/mvvm-xue-xi-vue-shi-jian-xiao-jie/)
[vuejs心法和技法 - 世有因果知因索果 - 博客园](http://www.cnblogs.com/kidsitcn/p/5409994.html)
[滴滴 webapp 5.0 Vue 2.0 重构经验分享 · Issue #13 · DDFE/DDFE-blog](https://github.com/DDFE/DDFE-blog/issues/13)
[vue-design/README.zh-CN.md at master · L-Chris/vue-design](https://github.com/L-Chris/vue-design/blob/master/README.zh-CN.md)
[Vue-Layout : vue可视化布局、自动生成代码 - CNode技术社区](https://cnodejs.org/topic/5993e5acf36051a45246c07a)
[Code Splitting With Vue.js And Webpack – Vue.js Developers – Medium](https://medium.com/js-dojo/code-splitting-with-vue-js-and-webpack-c9830b29d557)
[Advanced Vue.js concepts: mixins, custom directives, filters, transitions, and state management](https://blog.logrocket.com/advanced-vue-js-concepts-mixins-custom-directives-filters-transitions-and-state-management-ca6955905156)
[A Vue.js introduction for people who know just enough jQuery to get by](https://medium.freecodecamp.org/vue-js-introduction-for-people-who-know-just-enough-jquery-to-get-by-eab5aa193d77)
[JavaScript Event Loop 机制详解与 Vue.js 中实践应用](https://zhuanlan.zhihu.com/p/29116364)

[从零开始设计数据大屏—基于Vue - 简书](https://www.jianshu.com/p/cbbf9fc80edc)
[Vue-Access-Control/README_CN.md at master · tower1229/Vue-Access-Control](https://github.com/tower1229/Vue-Access-Control/blob/master/README_CN.md)

[基于vue的移动web app页面缓存解决方案 - 个人文章 - SegmentFault](https://segmentfault.com/a/1190000010428654)
[从1万篇文章中挑出的40篇最棒的 Vue 学习指南（2018版）](https://zhuanlan.zhihu.com/p/33642051?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)

# 单元测试
[Vue 2 Unit Testing Primer – Morningstar Engineering](https://morningstar.engineering/vue-2-unit-testing-primer-48d1d616a981)
[Write the first Vue.js Component Unit Test in Jest | Alex Jover Morales](https://alexjoverm.github.io/2017/08/21/Write-the-first-Vue-js-Component-Unit-Test-in-Jest/)s
[Unit Testing Vue.js Components with the Official Vue Testing Tools and Jest | Alex Jover Morales](https://alexjoverm.github.io/series/Unit-Testing-Vue-js-Components-with-the-Official-Vue-Testing-Tools-and-Jest/?utm_campaign=Revue%20newsletter&utm_medium=Newsletter&utm_source=Vue.js%20Feed)
[Vue 的单元测试探索（一）](https://zhuanlan.zhihu.com/p/26752090)
[全栈测试实战：用Jest测试Vue+Koa全栈应用 | MARKSZのBlog](https://molunerfinn.com/Use-Jest-To-Test-Vue-Koa/)
[写给后端开发者看的Vue前端介绍（二）--单元测试 | IO10|PangJian's Blog](https://www.pangjian.me/2018/01/12/vue-tutorial-for-ci/)

# 示例
webpack配置
[vue-boilerplate-template/webpack.dev.conf.js at master · nicejade/vue-boilerplate-template](https://github.com/nicejade/vue-boilerplate-template/blob/master/build/webpack.dev.conf.js)
[blade254353074/multi-vue: multi single-page-application with vue.js](https://github.com/blade254353074/multi-vue)
[Mrminfive/vue-multiple-page: vue + webpack 多页/单页 脚手架](https://github.com/Mrminfive/vue-multiple-page)
[multiple-page-vue-webpack-example/dev-server.js at master · lpreterite/multiple-page-vue-webpack-example](https://github.com/lpreterite/multiple-page-vue-webpack-example/blob/master/build/dev-server.js)
[annnhan/vue-spa-template: The base code of vue.js project.](https://github.com/annnhan/vue-spa-template)

[手摸手，带你用vue撸后台 系列三(实战篇) - 个人文章 - SegmentFault](https://segmentfault.com/a/1190000009762198)

实际运用
[用 Vue 写了个斗鱼的 Web App - V2EX](https://www.v2ex.com/t/293013)
[bailicangdu/vue2-elm: 基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用](https://github.com/bailicangdu/vue2-elm)
[lybenson/bilibili-vue: 前端vue+后端koa，全栈式开发bilibili首页](https://github.com/lybenson/bilibili-vue)

[zimplexing/vue-nReader: vue2.0 + vue-router + vuex 的 一个阅读webapp](https://github.com/zimplexing/vue-nReader)

## 源码学习
[Vue源码解读-参数合并(mergeOptions) | 滴滴商业FED](https://defed.github.io/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%8F%82%E6%95%B0%E5%90%88%E5%B9%B6-mergeOptions/)
[vue早期源码学习系列之二：如何监听一个数组的变化 · Issue #85 · youngwind/blog](https://github.com/youngwind/blog/issues/85)
[重复造轮子：从0开始实现Vue数据绑定 | Shellming's Note](http://shellming.com/2017/08/02/vue-data-binding/)
[callmedadaxin/proxy-vue: 借助各种es6新特性 实现vue的简单特性](https://github.com/callmedadaxin/proxy-vue)
[从vue源码来看Proxy的用途 - 前端学习 - SegmentFault](https://segmentfault.com/a/1190000008303003)
[从JavaScript属性描述器剖析Vue.js响应式视图 – 熊建刚的博客](http://blog.codingplayboy.com/2017/06/09/js_reactive_dom/)
[Vue.js源码中对于deep watching的巧妙实现](http://ife.baidu.com/note/detail/id/358)
[Vue源码解读-$Watch的内部实现 | 滴滴商业FED](https://defed.github.io/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-watch%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/)

vuejs中重用代码的几种方案

1. 创建自包含的组件，可以任意重用
2. 创建抽象组件，比如node，实体组件extends这个抽象组件，再添加自己的options，形成新的concret组件
3. mixins: 部分代码可以被任意无关的类，组件共用，这部分最适合使用mixin
4. 只负责对DOM操作的功能，则可以抽象为directive来重用

## template
如何绑定html元素属性要么为一个值，要么就没有?

<a :href="shouldhavehref ? 'http://xx.com/yy' : null">
上面的代码中判断shouldhavehref data值，如果该值为真则在a元素上存在href="http://xx.com/yy"，如果该值为假，则返回null，从而a元素上就不存在href属性!

组件的模板会替换自定义元素my-component标签，也就是说my-component只是作为一个挂载点而已，当然，这可以通过replace选项来改变这个缺省行为

## 数据驱动 reactive
数组
[列表渲染 — Vue.js](https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B)
vuejs可以被应用在数组的push,pop,shift,unshift,splice,sort,reverse方法改变数组的场景，但是如果你使用下面的语法改变数组，vuejs则无法感知这个变化
1. vm.items[0]={};
2. vm.items.length=0

vuejs推荐的解决方案是：
1. 使用`$set`方法： example1.items.$set(0,{});
2. 使用空数组来替换items即可 example1.items = [];

vuejs也提供了直接删除一个数组一个元素的简单方法 this.items.$remove(item)

Object.assign(this.$data, this.$options.data())

## watch
第一次执行不会 执行watch

``` javascript
this.$watch(
        function(){
            return this.sundayDate
        },
        function(){
            this.dates = [0, 1, 2, 3, 4, 5, 6].map(x=>this.sunday.day(x, 'd').format('D'))
        })

        watch:{
    sunday:{
        deep: true,
        handler: function(newVal, oldVal){
            this.dates = [0, 1, 2, 3, 4, 5, 6].map(x=>this.sunday.day(x, 'd').format('D'))
        }

    }

},
```

## 生命周期 lifecycle

created：vue实例被生成后的一个生命周期钩子函数。(页面初始化数据加载一般写这里);
beforeCreate：给个loading界面 created撤销loading;
beforeDestory：你确认删除XX吗？
destoryed：当前组件已被删除，清空相关内容

beforeDestory destoryed 由vm.destory()触发 或v-if v-for

beforeCreate(){
    console.log(this.cityName)
    console.log(this.$data)
},

把beforeCreate——>created看成一个vue实例从无到有的过程，但是这时它还没有渲染到dom上，只是一个存在于内存中的vue对象.
created——>mounted

这个阶段把vue对象渲染到dom，
比较document.querySelectorAll('.class');

beforeUpdate——>updated

这个过程是响应vue实例数据的变化时被调用的，一个vue实例上任一数据变化都会调用这个钩子。

使用这个函数要注意一点，只有某个数据被渲染到了dom上，这个数据的变化才会触发update函数。

[Vue.js 生命周期和route的生命周期讲解 - 简书](http://www.jianshu.com/p/e9f884b6ba6c)
[vue生命周期探究（一） - 肉丸的前端区 - SegmentFault](https://segmentfault.com/a/1190000008879966)
[vue生命周期探究（二） - 肉丸的前端区 - SegmentFault](https://segmentfault.com/a/1190000008923105)
[Understanding Vue.js Lifecycle Hooks ← Alligator.io](https://alligator.io/vuejs/component-lifecycle/)

```javascript
module.exports = {
        //props: ['父组建传的值'],
        data:function(){
            lifecycle.push("data");
            return {
                msg: '各个阶段，可以查看控制台输出，message from my-views',
                title:'my_views',
                lifecycle: lifecycle
            }
        },
        //这里是route的生存周期
        route:{
            //waitForData: true, //  数据加载完毕后再切换试图，也就是 点击之后先没反应，然后数据加载完，再出发过渡效果
            canActivate:function(transition){
                //  canActivate阶段，可以做一些用户验证的事情(是否可以被激活)
                //  在验证阶段，当一个组件将要被切入的时候被调用。
            },
            activate:function(transition){
                                //  在激活阶段被调用，在 activate 被断定（ resolved ，指该函数返回的 promise 被 resolve ）。用于加载和设置当前组件的数据。(激活)
                //this.$root.$set('header',this.title);
                transition.next();
                //此方法结束后，api会调用afterActivate 方法
                //在aftefActivate中 会给组件添加 $loadingRouteData 属性 并设置为true
            },
            data: function(transition) {
                var _this = this;
                //  在激活阶段被调用，在 activate 被断定（ resolved ，指该函数返回的 promise 被 resolve ）。用于加载和设置当前组件的数据
                // 说明之前请求过 则不用再请求了
                if(this.$root.myViewsData){
                    this.$data = this.$root.myViewsData;
                    transition.next();
                    console.log('已经请求过了不再请求数据');
                    return;
                }

                //将数据同步到根节点
                this.$root.myViewsData = this.$data;
                setTimeout(function(){
                    //这里 _this.$loadingRouteData 是 true
                    transition.next({msg:'加载后的数据'});
                    //在调用完transition.next 后，_this.$loadingRouteData 为 false
                }.bind(this),4000);
            },
            canDeactivate:function(transition){
                //  在验证阶段，当一个组件将要被切出的时候被调用。(是否可以被禁用)
            },
            deactivate: function (transition) {
                //  在激活阶段，当一个组件将要被禁用和移除之时被调用。(禁用)
            }
        },
        beforeCreate:function(){
            // 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。
        },
        created:function(){
            // 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。
        },
        beforeCreate:function(){
            // 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。
        },
        mounted:function(){
            // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。
        },
        beforeUpdate: function(){
            // 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。
            // 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。
        },
        Update: function(){
            // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。

            //当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。
        },

        // <keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
        activated: function(){
            // keep-alive 组件激活时调用。
        },
        deactivated: function(){
            // keep-alive 组件停用时调用。
        },

        beforeDestroy:function(){
            // 实例销毁之前调用。在这一步，实例仍然完全可用。
        },
        destroyed:function(){
            // Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
        }
    }
```

## 指令
[Vue 中使用 highlight.js · Ahonn](http://www.ahonn.me/2016/07/13/getting-highlightjs-to-work-with-vue.js/)

[hilongjw/vue-lazyload: A Vue.js plugin for lazyload your Image or Component in your application.](https://github.com/hilongjw/vue-lazyload)

customized directive的bind函数中如果返回this.vm到底指向的是谁呢？这有时候还是容易混淆不清的。一般性原则：如果该directive attached到一个component的template内部，则该值指向VueComponent,如果该directive attached dom node并不属于任何component,则这个值就直接指向root Vue instance.

## mixins
通常来说，不建议使用全局的 mixin，但总会有特殊需要，比如在本项目中，由于埋点和其他需要，几乎每个组件都要用到几个公用的全局数据，所以放到全局的 mixin 是最好不过的了 Vue.mixin(mixins)。使用全局的 mixin 要注意的是，不要把逻辑放到 mixin 里，因为每个组件都会执行一遍 mixin 的内容，组件一多就非常可怕了。

如果全局mixin和组件内mixin有同名的钩子函数，钩子函数都会执行，并且先执行全局后执行组件内。
对于非钩子函数，组件实例的对象属性，组件内的会覆盖全局的。
[Using Mixins in Vue.js | CSS-Tricks](https://css-tricks.com/using-mixins-vue-js/?utm_campaign=Revue%20newsletter&utm_medium=Newsletter&utm_source=revue)
[paulpflug/vue-mixins: A collection of mixins in vue](https://github.com/paulpflug/vue-mixins)

## plugin
[Vue入坑史，插件系统详解 - 简书](http://www.jianshu.com/p/3691620547e8)


## CLI
[vue-cli#2.0 webpack 配置分析 - 知乎专栏](https://zhuanlan.zhihu.com/p/24322005)
[vue-cli#2.0 webpack 配置分析 · Issue #10 · DDFE/DDFE-blog](https://github.com/DDFE/DDFE-blog/issues/10)
[使用 vue-cli 搭建项目详解之二 · Issue #7 · cy0707/Learn_Vue](https://github.com/cy0707/Learn_Vue/issues/7)
[简单总结vue-cli中的webpack配置 | seminelee blog](https://seminelee.github.io/2017/07/09/webpack-2/)
[vue-cli的webpack模板项目配置文件分析 - hongchh的博客 - CSDN博客](http://blog.csdn.net/hongchh/article/details/55113751)

## ssr
[安装 - Nuxt.js](https://zh.nuxtjs.org/guide/installation)
[github1586/nuxt-bnhcp: nuxt、SSR、vue、mysql、redis、nginx、socket.io NUXT(项目案例)](https://github.com/github1586/nuxt-bnhcp)

## weex
[可能是史上最全的weex踩坑攻略 - 简书](http://www.jianshu.com/p/497f1a9ff33f)
